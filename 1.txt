#include <Arduino.h>
#include <ArduinoJson.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <Preferences.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <BLE2902.h>
#include "mbedtls/base64.h"

// ========== UUID å®šä¹‰ ==========
#define SERVICE_UUID            "0000fff0-0000-1000-8000-00805f9b34fb"
#define CHARACTERISTIC_UUID_RX  "0000fff1-0000-1000-8000-00805f9b34fb" // æ‰‹æœº â†’ ESP32
#define CHARACTERISTIC_UUID_TX  "0000fff2-0000-1000-8000-00805f9b34fb" // ESP32 â†’ æ‰‹æœº
#define CHARACTERISTIC_UUID_ID  "0000fff3-0000-1000-8000-00805f9b34fb" // è®¾å¤‡IDï¼ˆåªè¯»ï¼‰

BLECharacteristic *pTxCharacteristic = nullptr;
BLECharacteristic *pIdCharacteristic = nullptr;
bool deviceConnected = false;
volatile bool wifiEventsInitialized = false;
unsigned long lastHeartbeatMs = 0;
unsigned long lastWifiRetryMs = 0; // å‘¨æœŸæ€§ Wi-Fi é‡è¯•è®¡æ—¶å™¨ï¼ˆæœªè¿æ¥æ—¶æ¯ 30 ç§’å°è¯•ï¼‰
String gSavedSsid = "";          // å†…å­˜ä¸­çš„å·²ä¿å­˜ SSID
String gSavedPwd = "";           // å†…å­˜ä¸­çš„å·²ä¿å­˜å¯†ç 
Preferences prefs;

// ===== Supabase REST (replace with your project-specific values) =====
// IMPORTANT: Do NOT hardcode anon keys in production firmware. Use device-scoped JWT with RLS.
const char* SUPABASE_REST_URL = "https://kjitkkeerytijbcgkqjj.supabase.co/rest/v1/devices?device_id=eq."; // append DEVICE_ID

String getStoredJwt() {
  // Load JWT issued during provisioning via BLE
  return prefs.getString("jwt", "");
}

String getDeviceId() {
  // Format: ESP32_XXXXXX where XXXXXX is last 6 of macToShortId()
  String shortId = macToShortId();
  String suffix = shortId.substring(max(0, (int)shortId.length() - 6));
  suffix.toUpperCase();
  return String("ESP32_") + suffix;
}

void postHeartbeat() {
  if (WiFi.status() != WL_CONNECTED) return;
  String deviceId = getDeviceId();
  String url = String(SUPABASE_REST_URL) + deviceId;
  HTTPClient http;
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  String jwt = getStoredJwt();
  if (jwt.length() == 0) {
    Serial.println("âš ï¸ No JWT stored; skip heartbeat");
    http.end();
    return;
  }
  // Send Authorization header only; your PostgREST setup should accept device JWT with RLS
  http.addHeader("Authorization", String("Bearer ") + jwt);

  // Build payload (server can treat updated_at/last_seen with now() via trigger, but we send explicit values)
  String payload = "{";
  payload += "\"status\":\"online\",";
  payload += String("\"wifi_signal\":") + String(WiFi.RSSI()) + String(",");
  payload += String("\"wifi_ssid\":\"") + String(WiFi.SSID().c_str()) + String("\"");
  payload += "}";

  int code = http.PATCH(payload);
  if (code > 0) {
    Serial.printf("ğŸ’“ Heartbeat PATCH code=%d\n", code);
  } else {
    Serial.printf("âŒ Heartbeat failed, code=%d\n", code);
  }
  http.end();
}

// ========== å·¥å…·å‡½æ•° ==========
String macToShortId() {
  uint64_t mac = ESP.getEfuseMac();
  uint32_t low = (uint32_t)(mac & 0xFFFFFFFF);
  char buf[16];
  snprintf(buf, sizeof(buf), "%08X", low);
  return String(buf);
}

bool looksBase64(const String& s) {
  // ç®€å•åˆ¤æ–­ï¼šé•¿åº¦ä¸º4çš„å€æ•°ï¼Œä¸”åªåŒ…å« Base64 å­—ç¬¦é›†
  if (s.length() == 0 || (s.length() % 4) != 0) return false;
  for (size_t i = 0; i < s.length(); ++i) {
    char c = s[i];
    bool ok = (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
              (c >= '0' && c <= '9') || c == '+' || c == '/' || c == '=';
    if (!ok) return false;
  }
  return true;
}

String base64DecodeToString(const String& b64) {
  size_t outLen = 0;
  // ä¼°ç®—è¾“å‡ºé•¿åº¦ï¼šBase64 çº¦ 3/4
  size_t allocLen = (b64.length() / 4) * 3 + 4;
  std::unique_ptr<unsigned char[]> out(new unsigned char[allocLen]);

  int ret = mbedtls_base64_decode(out.get(), allocLen, &outLen,
                                  (const unsigned char*)b64.c_str(), b64.length());
  if (ret == 0) {
    return String((const char*)out.get(), outLen);
  } else {
    return String("");
  }
}

String toHex(const String& s) {
  String hex = "";
  for (size_t i = 0; i < s.length(); ++i) {
    char buf[4];
    sprintf(buf, "%02X", (uint8_t)s[i]);
    hex += buf;
    if (i + 1 < s.length()) hex += " ";
  }
  return hex;
}

void txNotify(const String& msg) {
  if (!pTxCharacteristic) return;
  pTxCharacteristic->setValue(msg.c_str());
  pTxCharacteristic->notify();
}

// æ¨é€å‰5ä¸ªæ‰«æåˆ°çš„ Wi-Fi SSID åŠ RSSI/åŠ å¯†ç±»å‹
void notifyWifiListTop5() {
  txNotify("WIFI_LIST_BEGIN");
  Serial.println("ğŸ” WIFI_LIST: scanning...");

  int n = WiFi.scanNetworks();
  if (n <= 0) {
    Serial.println("âš ï¸ No networks found");
    txNotify("WIFI_LIST_NONE");
    txNotify("WIFI_LIST_END");
    return;
  }

  // é€‰æ‹© RSSI æœ€å¼ºçš„å‰5ä¸ªï¼ˆä¸åšå¤æ‚å»é‡ï¼Œè‹¥æœ‰åŒåSSIDå¯èƒ½é‡å¤ï¼‰
  const int MAX_ITEMS = 5;
  bool selected[50];
  int maxCheck = min(50, n);
  for (int i = 0; i < maxCheck; ++i) selected[i] = false;

  int emitted = 0;
  while (emitted < MAX_ITEMS) {
    int bestIdx = -1;
    int bestRssi = -9999;
    for (int i = 0; i < maxCheck; ++i) {
      if (selected[i]) continue;
      int rssi = WiFi.RSSI(i);
      if (rssi > bestRssi) { bestRssi = rssi; bestIdx = i; }
    }
    if (bestIdx == -1) break; // æ²¡æœ‰æ›´å¤š
    selected[bestIdx] = true;

    String ssid = WiFi.SSID(bestIdx);
    int rssi = WiFi.RSSI(bestIdx);
    wifi_auth_mode_t enc = (wifi_auth_mode_t)WiFi.encryptionType(bestIdx);
    String encStr = encTypeToStr(enc);

    // æ ¼å¼ï¼šWIFI_ITEM <SSID>|<RSSI>|<ENC>
    String line = String("WIFI_ITEM ") + ssid + "|" + String(rssi) + "|" + encStr;
    txNotify(line);
    Serial.println(line);
    emitted++;
  }

  txNotify(String("WIFI_LIST_COUNT ") + String(n));
  txNotify("WIFI_LIST_END");
}

// ========== Wi-Fi äº‹ä»¶å¤„ç† ==========
String encTypeToStr(wifi_auth_mode_t auth) {
  switch (auth) {
    case WIFI_AUTH_OPEN: return "OPEN";
    case WIFI_AUTH_WEP: return "WEP";
    case WIFI_AUTH_WPA_PSK: return "WPA_PSK";
    case WIFI_AUTH_WPA2_PSK: return "WPA2_PSK";
    case WIFI_AUTH_WPA_WPA2_PSK: return "WPA/WPA2_PSK";
    case WIFI_AUTH_WPA2_ENTERPRISE: return "WPA2_ENT";
    case WIFI_AUTH_WPA3_PSK: return "WPA3_PSK";
    case WIFI_AUTH_WPA2_WPA3_PSK: return "WPA2/WPA3_PSK";
    default: return "UNKNOWN";
  }
}

void setupWifiEvents() {
  if (wifiEventsInitialized) return;
  WiFi.onEvent([](WiFiEvent_t event, WiFiEventInfo_t info){
    switch (event) {
      case ARDUINO_EVENT_WIFI_STA_CONNECTED:
        Serial.println("ğŸ“¡ WiFi STA connected to AP");
        txNotify("WIFI_STA_CONNECTED");
        break;
      case ARDUINO_EVENT_WIFI_STA_GOT_IP:
        Serial.printf("ğŸŒ Got IP: %s\n", WiFi.localIP().toString().c_str());
        txNotify("WIFI_OK");
        break;
      case ARDUINO_EVENT_WIFI_STA_DISCONNECTED: {
        int r = info.wifi_sta_disconnected.reason;
        Serial.printf("âš ï¸ WiFi STA disconnected, reason=%d\n", r);
        // Map some common reasons
        if (r == WIFI_REASON_AUTH_EXPIRE || r == WIFI_REASON_AUTH_LEAVE || r == WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT || r == WIFI_REASON_HANDSHAKE_TIMEOUT) {
          txNotify("WIFI_AUTH_FAIL");
        } else if (r == WIFI_REASON_NO_AP_FOUND) {
          txNotify("WIFI_AP_NOT_FOUND");
        } else {
          String msg = String("WIFI_DISCONNECTED_REASON_") + String(r);
          txNotify(msg);
        }
        break;
      }
      default:
        break;
    }
  });
  wifiEventsInitialized = true;
}

// ========== BLE è¿æ¥çŠ¶æ€å›è°ƒ ==========
class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer *pServer) override {
    deviceConnected = true;
    Serial.println("âœ… Device connected!");
    // å¯é€‰ï¼šè¿æ¥å 500ms å‘é€ HELLO
    delay(500);
    txNotify("HELLO");
  }

  void onDisconnect(BLEServer *pServer) override {
    deviceConnected = false;
    Serial.println("âŒ Device disconnected, restarting advertising...");
    BLEDevice::startAdvertising();
  }
};

// ========== Wi-Fi è‡ªåŠ¨è¿æ¥å‡½æ•° ==========
void connectToWiFi(const char* ssid, const char* password) {
  Serial.printf("ğŸ“¶ Connecting to Wi-Fi: %s\n", ssid);
  txNotify("WIFI_CONNECTING");
  setupWifiEvents();
  WiFi.disconnect(true, true);
  delay(200);
  WiFi.mode(WIFI_STA);
  WiFi.setAutoReconnect(true);
  WiFi.setSleep(false);

  // å…ˆæ‰«æç¡®è®¤ AP å­˜åœ¨ï¼Œå¹¶æ‰“å°ä¿¡æ¯
  Serial.println("ğŸ” Scanning networks...");
  int n = WiFi.scanNetworks();
  bool found = false;
  int foundIndex = -1;
  for (int i = 0; i < n; ++i) {
    String ss = WiFi.SSID(i);
    if (ss == ssid) {
      found = true;
      foundIndex = i;
      int rssi = WiFi.RSSI(i);
      wifi_auth_mode_t enc = (wifi_auth_mode_t)WiFi.encryptionType(i);
      Serial.printf("âœ… Found SSID '%s', RSSI=%d, enc=%s\n", ss.c_str(), rssi, encTypeToStr(enc).c_str());
      break;
    }
  }
  if (!found) {
    Serial.println("âŒ AP not found by scan");
    txNotify("WIFI_AP_NOT_FOUND");
    return;
  }

  WiFi.begin(ssid, password);

  unsigned long startAttemptTime = millis();
  const unsigned long timeout = 25000; // 25 ç§’è¶…æ—¶

  while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < timeout) {
    delay(500);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.printf("\nâœ… Wi-Fi Connected! IP: %s\n", WiFi.localIP().toString().c_str());
    txNotify("WIFI_OK");
    // Immediately send a heartbeat after successful connection
    lastHeartbeatMs = 0; // force immediate
    postHeartbeat();
  } else {
    Serial.println("\nâŒ Wi-Fi Connect Failed!");
    // å°è¯•æ ¹æ®çŠ¶æ€ç»™å‡ºæ›´æ˜ç¡®çš„é€šçŸ¥
    if (WiFi.status() == WL_CONNECT_FAILED) {
      txNotify("WIFI_AUTH_FAIL");
    } else {
      txNotify("WIFI_FAIL");
    }
  }
}

// ========== BLE å†™å…¥å›è°ƒ ==========
class MyCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pCharacteristic) override {
    // Handle both Arduino String and std::string return types across BLE libs
    // Use auto and c_str() which is available on both String and std::string
    String rxValue;
    {
      auto val = pCharacteristic->getValue();
      rxValue = String(val.c_str());
    }

    // è¯¦ç»†æ—¥å¿—
    String ts = String(millis());
    Serial.println("====== onWrite ======");
    Serial.printf("â±ï¸ millis: %s\n", ts.c_str());
    Serial.printf("UUID: %s\n", pCharacteristic->getUUID().toString().c_str());
    Serial.printf("Len: %d\n", rxValue.length());
    Serial.printf("Raw: %s\n", rxValue.c_str());
    Serial.printf("Hex: %s\n", toHex(rxValue).c_str());

    if (rxValue.length() == 0) {
      Serial.println("âŒ Received empty data!");
      txNotify("EMPTY_DATA");
      return;
    }

    // ç«‹å³ç¡®è®¤å·²æ”¶åˆ°
    txNotify("DATA_RECEIVED");

    // PING æ£€æµ‹ï¼ˆå­—ç¬¦ä¸²æˆ– Base64ï¼‰
    if (rxValue == "PING") {
      Serial.println("âœ… Received PING (string)");
      txNotify("ACK_PING");
      return;
    }
    if (rxValue == "UElORw==") {
      // Base64 for "PING"
      Serial.println("âœ… Received PING (Base64)");
      txNotify("ACK_PING");
      return;
    }

    // WIFI_LIST æ‰«æè¯·æ±‚ï¼ˆæ˜æ–‡ï¼‰
    if (rxValue == "WIFI_LIST") {
      notifyWifiListTop5();
      return;
    }

    // If it looks like Base64, attempt to decode and treat decoded payload
    if (looksBase64(rxValue)) {
      String decoded = base64DecodeToString(rxValue);
      Serial.printf("ğŸ“¥ Decoded (len=%d): %s\n", decoded.length(), decoded.c_str());
      // If decoded is exactly PING
      if (decoded == "PING") {
        Serial.println("âœ… Decoded PING");
        txNotify("ACK_PING");
        return;
      }
      // If decoded is exactly WIFI_LIST
      if (decoded == "WIFI_LIST") {
        notifyWifiListTop5();
        return;
      }
      // Try JSON WiFi config from decoded
      if (decoded.startsWith("{") && decoded.endsWith("}")) {
        DynamicJsonDocument doc(2048);
        DeserializationError err = deserializeJson(doc, decoded);
        if (err) {
          Serial.printf("âŒ JSON parse error (b64): %s\n", err.c_str());
          txNotify("JSON_PARSE_FAIL");
          return;
        }
        const char* ssid = doc["ssid"] | "";
        const char* password = doc["password"] | "";
        const char* jwt = doc["jwt"] | "";
        if (strlen(ssid) == 0 && strlen(jwt) > 0) {
          // JWT-only provisioning message: store token and ack
          prefs.putString("jwt", String(jwt));
          Serial.println("âœ… Stored JWT (b64 JSON)");
          txNotify("JWT_SAVED");
          return;
        }
        if (strlen(ssid) == 0) {
          Serial.println("âŒ Missing ssid in JSON (b64)");
          txNotify("JSON_MISSING_SSID");
          return;
        }
        if (strlen(jwt) > 0) {
          prefs.putString("jwt", String(jwt));
          Serial.println("âœ… Stored JWT from provisioning payload");
        }
        // æŒä¹…åŒ– Wi-Fi å‡­æ®ï¼Œæ”¯æŒæ–­ç”µé‡å¯åè‡ªåŠ¨è¿æ¥
        prefs.putString("wifi_ssid", String(ssid));
        prefs.putString("wifi_pwd", String(password));
        Serial.printf("ğŸ’¾ Saved Wi-Fi creds: SSID='%s' (pwd length=%d)\n", ssid, (int)String(password).length());
        // æ›´æ–°å†…å­˜ä¸­çš„å‡­æ®ç”¨äºå‘¨æœŸæ€§é‡è¯•
        gSavedSsid = String(ssid);
        gSavedPwd = String(password);
        connectToWiFi(ssid, password);
        return;
      }
      // Unknown decoded content
      txNotify("UNKNOWN_DECODED");
      return;
    }

    // Plain JSON WiFi config
    if (rxValue.startsWith("{") && rxValue.endsWith("}")) {
      DynamicJsonDocument doc(2048);
      DeserializationError err = deserializeJson(doc, rxValue);
      if (err) {
        Serial.printf("âŒ JSON parse error: %s\n", err.c_str());
        txNotify("JSON_PARSE_FAIL");
        return;
      }
      const char* ssid = doc["ssid"] | "";
      const char* password = doc["password"] | "";
      const char* jwt = doc["jwt"] | "";
      if (strlen(ssid) == 0 && strlen(jwt) > 0) {
        // JWT-only message: store and ack
        prefs.putString("jwt", String(jwt));
        Serial.println("âœ… Stored JWT (plain JSON)");
        txNotify("JWT_SAVED");
        return;
      }
      if (strlen(ssid) == 0) {
        Serial.println("âŒ Missing ssid in JSON");
        txNotify("JSON_MISSING_SSID");
        return;
      }
      if (strlen(jwt) > 0) {
        prefs.putString("jwt", String(jwt));
        Serial.println("âœ… Stored JWT from JSON payload");
      }
      // æŒä¹…åŒ– Wi-Fi å‡­æ®ï¼Œæ”¯æŒæ–­ç”µé‡å¯åè‡ªåŠ¨è¿æ¥
      prefs.putString("wifi_ssid", String(ssid));
      prefs.putString("wifi_pwd", String(password));
      Serial.printf("ğŸ’¾ Saved Wi-Fi creds: SSID='%s' (pwd length=%d)\n", ssid, (int)String(password).length());
      // æ›´æ–°å†…å­˜ä¸­çš„å‡­æ®ç”¨äºå‘¨æœŸæ€§é‡è¯•
      gSavedSsid = String(ssid);
      gSavedPwd = String(password);
      connectToWiFi(ssid, password);
      return;
    }

    // Optional plaintext command: WIFI_SET SSID=<ssid> PWD=<pwd>
    if (rxValue.startsWith("WIFI_SET")) {
      String ssid = "";
      String pwd = "";
      // very simple parsing; format: WIFI_SET SSID=xxx PWD=yyy
      int sPos = rxValue.indexOf("SSID=");
      int pPos = rxValue.indexOf("PWD=");
      if (sPos != -1) {
        int sEnd = rxValue.indexOf(' ', sPos);
        ssid = (sEnd == -1) ? rxValue.substring(sPos + 5) : rxValue.substring(sPos + 5, sEnd);
      }
      if (pPos != -1) {
        int pEnd = rxValue.indexOf(' ', pPos);
        pwd = (pEnd == -1) ? rxValue.substring(pPos + 4) : rxValue.substring(pPos + 4, pEnd);
      }
      if (ssid.length() == 0) {
        Serial.println("âŒ WIFI_SET missing SSID");
        txNotify("WIFI_SET_MISSING_SSID");
        return;
      }
      // ä¿å­˜å‡­æ®ä»¥ä¾¿æ–­ç”µé‡å¯è‡ªåŠ¨è¿æ¥
      prefs.putString("wifi_ssid", ssid);
      prefs.putString("wifi_pwd", pwd);
      Serial.printf("ğŸ’¾ Saved Wi-Fi creds via WIFI_SET: SSID='%s' (pwd length=%d)\n", ssid.c_str(), (int)pwd.length());
      // æ›´æ–°å†…å­˜ä¸­çš„å‡­æ®ç”¨äºå‘¨æœŸæ€§é‡è¯•
      gSavedSsid = ssid;
      gSavedPwd = pwd;
      connectToWiFi(ssid.c_str(), pwd.c_str());
      return;
    }

    // æ¸…é™¤å·²ä¿å­˜çš„ Wi-Fi å‡­æ®ï¼ˆä¸æ¸…é™¤ JWTï¼‰
    if (rxValue == "WIFI_CLEAR") {
      bool hadSsid = prefs.isKey("wifi_ssid");
      bool hadPwd = prefs.isKey("wifi_pwd");
      prefs.remove("wifi_ssid");
      prefs.remove("wifi_pwd");
      Serial.printf("ğŸ§¹ Cleared saved Wi-Fi creds (had ssid=%s, pwd=%s)\n", hadSsid ? "yes" : "no", hadPwd ? "yes" : "no");
      txNotify("WIFI_CLEARED");
      gSavedSsid = "";
      gSavedPwd = "";
      return;
    }

    // Fallback
    Serial.println("â„¹ï¸ Unknown command");
    txNotify("UNKNOWN_CMD");
  }
};

// ========== BLE åˆå§‹åŒ– ==========
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\nBooting BLE_SPP_PinmeID...");
  // Init NVS preferences for storing device JWT
  prefs.begin("pinme", false);

  BLEDevice::init("pinme-ESP32");
  BLEServer *pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService *pService = pServer->createService(SERVICE_UUID);

  // TX characteristic (ESP32 -> Phone)
  pTxCharacteristic = pService->createCharacteristic(
      CHARACTERISTIC_UUID_TX,
      BLECharacteristic::PROPERTY_NOTIFY | BLECharacteristic::PROPERTY_READ);
  pTxCharacteristic->addDescriptor(new BLE2902());

  // RX characteristic (Phone -> ESP32)
  BLECharacteristic *pRxCharacteristic = pService->createCharacteristic(
      CHARACTERISTIC_UUID_RX,
      BLECharacteristic::PROPERTY_WRITE | BLECharacteristic::PROPERTY_WRITE_NR);
  pRxCharacteristic->setCallbacks(new MyCallbacks());

  // ID characteristic (read-only)
  pIdCharacteristic = pService->createCharacteristic(
      CHARACTERISTIC_UUID_ID,
      BLECharacteristic::PROPERTY_READ);
  String shortId = macToShortId();
  pIdCharacteristic->setValue(shortId.c_str());

  pService->start();

  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);  // helps iPhone
  pAdvertising->setMinPreferred(0x12);
  BLEDevice::startAdvertising();
  Serial.println("âœ… BLE Advertising started: pinme-ESP32");
  // åˆå§‹çŠ¶æ€é€šçŸ¥
  txNotify("WIFI_IDLE");
  // ======= å¼€æœºè‡ªåŠ¨è¿æ¥ï¼ˆè‹¥å·²ä¿å­˜ Wi-Fi å‡­æ®ï¼‰ =======
  String savedSsid = prefs.getString("wifi_ssid", "");
  String savedPwd = prefs.getString("wifi_pwd", "");
  gSavedSsid = savedSsid;
  gSavedPwd = savedPwd;
  if (savedSsid.length() > 0) {
    Serial.printf("ğŸ”„ Auto-connect using saved SSID: %s\n", savedSsid.c_str());
    // è‹¥ä¿å­˜äº† JWTï¼Œä¼˜å…ˆç”¨äºå¿ƒè·³æˆæƒ
    String jwt = getStoredJwt();
    if (jwt.length() == 0) {
      Serial.println("â„¹ï¸ No JWT saved yet; heartbeats will be skipped until one is provisioned.");
    }
    connectToWiFi(gSavedSsid.c_str(), gSavedPwd.c_str());
  } else {
    Serial.println("â„¹ï¸ No saved Wi-Fi credentials. Waiting for BLE provisioning.");
  }
}

void loop() {
  // Keep the loop light; BLE callbacks and WiFi handle most work
  delay(200);
  // ===== å‘¨æœŸæ€§é‡è¯•ï¼šå½“æœªè¿æ¥ä¸”å­˜åœ¨ä¿å­˜çš„å‡­æ®æ—¶ï¼Œæ¯ 30 ç§’å°è¯•ä¸€æ¬¡è¿æ¥ =====
  if (WiFi.status() != WL_CONNECTED) {
    unsigned long nowMs = millis();
    if (gSavedSsid.length() > 0 && nowMs - lastWifiRetryMs > 30000UL) {
      Serial.println("ğŸ” Periodic Wi-Fi retry (30s)");
      connectToWiFi(gSavedSsid.c_str(), gSavedPwd.c_str());
      lastWifiRetryMs = nowMs;
    }
  }
// Periodic heartbeat every 3 minutes
  if (WiFi.status() == WL_CONNECTED) {
    unsigned long nowMs = millis();
  if (nowMs - lastHeartbeatMs > 180000UL) {
    postHeartbeat();
    lastHeartbeatMs = nowMs;
  }
  }
}
è¿™ä¸ªæ–‡ä»¶æœ‰ä¹ˆæœ‰å®šæ—¶ä¸ŠæŠ¥ ä¿æŒå¿ƒè·³çš„åŠŸèƒ½